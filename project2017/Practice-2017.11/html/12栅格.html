<!DOCTYPE html>  
<html>  
<head>  
    <meta charset="utf-8">  
    <title>十二栅格</title>  
    <link href="http://apps.bdimg.com/libs/bootstrap/3.3.0/css/bootstrap.min.css" rel="stylesheet">  
    <style type="text/css">
        body{padding:20px;}  
    </style>  
</head>  
<body>  
    <!--<div class="container">
        <div class="row">
            <div class="col-xs-3 col-md-6 col-lg-4" style="border:2px solid green;">
                this提供了一种优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。随着使用模式越来越复杂，显式传递上下文对象会让代码变得混乱，而使用this则不会这样。(this引用的是函数据以执行的环境对象)this提供了一种优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。随着使用模式越来越复杂，显式传递上下文对象会让代码变得混乱，而使用this则不会这样。(this引用的是函数据以执行的环境对象)this提供了一种优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。随着使用模式越来越复杂，显式传递上下文对象会让代码变得混乱，而使用this则不会这样。(this引用的是函数据以执行的环境对象)
            </div>
            <div class="col-xs-9 col-md-6 col-lg-8" style="border:2px solid green;">
                在调用函数时，我们会将调出处执行环境对象传给this，如此处调用fun(2)，处在全局作用域中，因此this会指向window。既然这样，我们可以通过强制this指向fun函数对象来解决这个问题，JS提供了两个函数，apply()和call()函数.apply()方法接收两个参数：一个是在其中运行函数的作用域（可以理解为是this的值），另一个是参数数组（可以是arguments或者是数组的实例）call()方法与apply()方法的作用相同，区别仅在于接收参数的方式不同。第一个参数都是this的值，但是使用call()方法，必须要将传递的参数逐个列举出来。在调用函数时，我们会将调出处执行环境对象传给this，如此处调用fun(2)，处在全局作用域中，因此this会指向window。既然这样，我们可以通过强制this指向fun函数对象来解决这个问题，JS提供了两个函数，apply()和call()函数.apply()方法接收两个参数：一个是在其中运行函数的作用域（可以理解为是this的值），另一个是参数数组（可以是arguments或者是数组的实例）call()方法与apply()方法的作用相同，区别仅在于接收参数的方式不同。第一个参数都是this的值，但是使用call()方法，必须要将传递的参数逐个列举出来。在调用函数时，我们会将调出处执行环境对象传给this，如此处调用fun(2)，处在全局作用域中，因此this会指向window。既然这样，我们可以通过强制this指向fun函数对象来解决这个问题，JS提供了两个函数，apply()和call()函数.apply()方法接收两个参数：一个是在其中运行函数的作用域（可以理解为是this的值），另一个是参数数组（可以是arguments或者是数组的实例）call()方法与apply()方法的作用相同，区别仅在于接收参数的方式不同。第一个参数都是this的值，但是使用call()方法，必须要将传递的参数逐个列举出来。
            </div>
        </div>
    </div>-->

    <!--<div class="container">
      <div class="row" style="border:2px solid red;">
          <div class="col-xs-3 col-md-6 col-lg-3 col-lg-offset-3" style="border:2px solid green;">
              this提供了一种优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。随着使用模式越来越复杂，
              显式传递上下文对象会让代码变得混乱，而使用this则不会这样。（this引用的是函数据以执行的环境对象）
          </div>
      </div>
  </div>-->

<div class="container">
    <div class="row" style="border:2px solid red;">
        <div class="col-lg-3 " style="border:2px solid green;background:#ccc;">
            this提供了一种优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。随着使用模式越来越复杂，显式传递上下文对象会让代码变得混乱，而使用this则不会这样。（this引用的是函数据以执行的环境对象）
        </div>
        <div class="col-lg-9">        
            <div class="col-lg-2" style="background:pink;">
                你好吗？会越来越好的，对吗？
            </div>
            <div class="col-lg-2" style="border:2px solid yellow;">
                越努力越幸福
                行动起来！
                不要做语言的巨人，行动的矮子
            </div>
            <div class="col-lg-8">
                <div class="col-lg-4" style="background:#FFD782;">
                    再见2015年
                    你好2016年
                </div>
                <div class="col-lg-6" style="background:#A8FFE2;">
                    愿时光待你温柔一些。
                    最纠结的时候就是你人生最重要的时候
                    不要在不安中度过一生
                </div>
            </div>
        </div>
    </div>
</div>
</body>  
</html>  